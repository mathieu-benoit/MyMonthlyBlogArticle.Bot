trigger:
  batch: true
  branches:
    include: 
    - '*'
  paths:
    exclude:
    - README.md
    - FlowAndArchitecture.PNG

pr: none

variables:
  vmImage: 'ubuntu-16.04'
  helmVersion: 3.0.2
  registryServerName: '$(registryName).azurecr.io'
  projectName: mymonthlyblogarticlebot
  terraformVersion: 0.12.18
  tfPlanArtifactName: 'tf-plan'
  helmChartVersionArtifactName: 'helm-chart-version'
  location: eastus
  hostName: $(dnsName).$(location).cloudapp.azure.com
  nginxIngressVersion: 0.26.2

stages:
- stage: 'Build'
  displayName: 'Build'
  jobs:
  - job: 'Package_Terraform_Templates'
    variables:
      imageTag: $(build.buildId)
    displayName: 'package and expose terraform templates'
    pool:
      vmImage: $(vmImage)
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(terraformVersion)
    - script: |
        cd tf
        terraform init \
            -backend-config="storage_account_name=$(tfStateStorageAccountName)" \
            -backend-config="container_name=$(projectName)"
        terraform plan \
            -var bot_name=$(projectName) \
            -var location=$(location) \
            -var microsoft_app_id=$(microsoftAppId) \
            -var bot_endpoint=https://$(hostName)/api/messages \
            -out=tf-plan
      failOnStderr: true
      displayName: 'terraform plan'
      env:
          ARM_TENANT_ID: $(tfTenantId)
          ARM_SUBSCRIPTION_ID: $(tfSubscriptionId)
          ARM_CLIENT_ID: $(tfClientId)
          ARM_CLIENT_SECRET: $(tfClientSecret)
          ARM_ACCESS_KEY: $(tfStateStorageAccountAccessKey)
    - publish: '$(system.defaultWorkingDirectory)/tf'
      artifact: $(tfPlanArtifactName)
  - job: 'Build_Container_Image'
    variables:
      imageTag: $(build.buildId)
    displayName: 'build and push container image'
    pool:
      vmImage: $(vmImage)
    steps:
    - bash: |
        docker build \
            -t $(projectName)-unittests:$(imageTag) \
            --target unittests \
            .
        id=$(docker create $(projectName)-unittests:$(imageTag))
        docker cp $id:/app/test/TestResults/ ./TestResults
        docker rm $id
      displayName: 'run unit tests'
    - task: PublishTestResults@2
      condition: succeededOrFailed()  
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        searchFolder: '$(System.DefaultWorkingDirectory)/TestResults'
        publishRunAttachments: true
      displayName: 'publish test results'
    - bash: |
        docker build \
            -t $(registryServerName)/$(projectName):$(imageTag) \
            .
      failOnStderr: true
      displayName: 'docker build'
    - bash: |
        echo $(registryPassword) | docker login \
            $(registryServerName) \
            -u $(registryLogin) \
            --password-stdin
      displayName: 'docker login'
    - bash: |
        docker push $(registryServerName)/$(projectName):$(imageTag)
      failOnStderr: true
      displayName: 'docker push'
  - job: 'Package_Helm_Chart'
    variables:
      imageTag: $(build.buildId)
      helmChartVersion: $(build.buildId)
    displayName: 'package and push helm chart'
    pool:
      vmImage: $(vmImage)
    steps:
    - task: HelmInstaller@1
      displayName: 'install helm'
      inputs:
        helmVersionToInstall: $(helmVersion)
    - bash: |
        cd chart/
        helm dependency update
        helm package \
            --version $(helmChartVersion) \
            --app-version $(imageTag) \
            .
      failOnStderr: true
      displayName: 'helm package'
    - bash: |
        cd chart/
        chartPackage=$(ls $(projectName)-*.tgz)
        az acr helm push \
            -n $(registryName) \
            -u $(registryLogin) \
            -p $(registryPassword) \
            $chartPackage
        echo $(jq -n --arg version "$(helmChartVersion)" '{helmChartVersion: $version}') > $(build.artifactStagingDirectory)/variables.json
      failOnStderr: true
      name: helmPush
      displayName: 'az acr helm push'
    - publish: $(build.artifactStagingDirectory)
      artifact: $(helmChartVersionArtifactName)
- stage: 'Release'
  displayName: 'Release'
  jobs:
  - deployment: Deploy_Terraform_Templates
    displayName: 'deploy terraform templates'
    pool:
      vmImage: 'ubuntu-16.04'
    environment: release-$(projectName)
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: none
          - download: current
            artifact: $(tfPlanArtifactName)
          - task: TerraformInstaller@0
            inputs:
              terraformVersion: $(terraformVersion)
          - script: |
              chmod +x .terraform/plugins/linux_amd64/terraform-provider-azurerm_v1.*
              terraform apply tf-plan
              appInsightsInstrumentationKey=$(terraform output app_insights_instrumentation_key)
              echo "##vso[task.setvariable variable=appInsightsInstrumentationKey;isOutput=true]$appInsightsInstrumentationKey"
            workingDirectory: $(pipeline.workspace)/$(tfPlanArtifactName)
            failOnStderr: true
            name: Terraform_Apply
            displayName: 'Terraform apply'
            env:
                ARM_TENANT_ID: $(tfTenantId)
                ARM_SUBSCRIPTION_ID: $(tfSubscriptionId)
                ARM_CLIENT_ID: $(tfClientId)
                ARM_CLIENT_SECRET: $(tfClientSecret)
                ARM_ACCESS_KEY: $(tfStateStorageAccountAccessKey)
  - job: Deploy_Helm_Chart
    dependsOn: Deploy_Terraform_Templates
    variables:
      k8sNamespace: $(projectName)
      appInsightsInstrumentationKey: $[ dependencies.Deploy_Terraform_Templates.outputs['Deploy_Terraform_Templates.Terraform_Apply.appInsightsInstrumentationKey'] ]
    displayName: 'deploy helm chart into aks'
    pool:
      vmImage: $(vmImage)
    steps:
    - checkout: none
    - task: HelmInstaller@1
      displayName: 'install helm'
      inputs:
        helmVersionToInstall: $(helmVersion)
    - download: current
      artifact: $(helmChartVersionArtifactName)
    - bash: |
        az login \
            --service-principal \
            -u $(aksSpId) \
            -p $(aksSpSecret) \
            --tenant $(aksSpTenantId)
        az aks get-credentials \
            -n $(aks) \
            -g $(aks)
        helm repo add \
            $(registryName) \
            https://$(registryServerName)/helm/v1/repo \
            --username $(registryLogin) \
            --password $(registryPassword)
        helmChartVersion=$(jq .helmChartVersion $(pipeline.workspace)/$(helmChartVersionArtifactName)/variables.json -r)
        helm upgrade \
            --namespace $(k8sNamespace) \
            --install \
            --wait \
            --version $helmChartVersion \
            --set image.repository=$(registryServerName)/$(projectName) \
            --set image.env.microsoftAppId=$(microsoftAppId) \
            --set image.env.microsoftAppPassword=$(microsoftAppPassword) \
            --set image.env.appInsights.instrumentationKey=$(appInsightsInstrumentationKey) \
            --set image.env.search.serviceName=$(azureSearchServiceName) \
            --set image.env.search.indexName=$(azureSearchIndexName) \
            --set image.env.search.serviceQueryApiKey=$(azureSearchServiceQueryApiKey) \
            --set networkpolicies.enabled=$(networkPoliciesEnabled) \
            --set ingress.hostName=$(hostName) \
            --set issuer.acme.email=$(issuerEmail) \
            --set nginx-ingress.defaultBackend.enabled=false \
            --set nginx-ingress.controller.image.tag=$(nginxIngressVersion) \
            --set nginx-ingress.controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$(dnsName) \
            $(projectName) \
            $(registryName)/$(projectName)
      failOnStderr: true
      displayName: 'deploy helm chart'
